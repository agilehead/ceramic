(function() {
    "use strict";

    var co = require("co");
    var JaySchema = require('jayschema');

    /*
        TODO: Well, this is kinda simplistic.
    */
    var isPrimitiveType = function(type) {
        return ['string', 'number', 'integer', 'boolean', 'array'].indexOf(type) > -1;
    };

    var schemaCache = {};


    var schemaLoader = function(name, cb) {
        var self = this;
        co(function*() {
            try {
                var entitySchema = yield* self.getEntitySchema(name);
                cb(null, entitySchema.schema);
            } catch (err) {
                cb(err);
            }
        });
    };


    var SchemaManager = function(options) {
        if (options) {
            if (options.fn) {
                //mustConstruct can also be substituted by deriving from SchemaManager
                if (options.fn.mustConstruct)
                    this.mustConstruct = options.fn.mustConstruct;

                //getDynamicEntitySchema can also be substituted by deriving from SchemaManager
                if (options.fn.getDynamicEntitySchema)
                    this.getDynamicEntitySchema = options.fn.getDynamicEntitySchema;
            }
        }

        this.jayschema = new JaySchema(schemaLoader.bind(this));
    };


    SchemaManager.prototype.completeEntitySchema = function*(def) {
        if (!def.schema || !def.schema.id)
            throw new Error("missing schema.id");

        if (!def.schema.properties) {
            def.schema.properties = {};
        }
        if (!def.schema.required) {
            def.schema.required = [];
        }
        if (def.autoGenerated) {
            for (var k in def.autoGenerated) {
                def.schema.properties[k] = {
                    type: 'integer'
                };
                def.schema.required.push(k);
            }
        }

        return def;
    };



    SchemaManager.prototype.completeVirtualEntitySchema = function*(virtualTypeDef, baseEntitySchema) {
        var def = JSON.parse(JSON.stringify(baseEntitySchema));

        def.schema.id = virtualTypeDef.schema.id;
        def.baseEntitySchema = baseEntitySchema;

        for (var kvirt in virtualTypeDef) {
            if (typeof(def[kvirt]) === "undefined" || def[kvirt] === null)
                def[kvirt] = virtualTypeDef[kvirt];
        }

        if (typeof(def.schema) === "undefined" || def.schema === null)
            def.schema = {};

        if (virtualTypeDef.schema) {
            for (var kschema in virtualTypeDef.schema) {
                if (typeof(def.schema[kschema]) === "undefined" || def.schema[kschema] === null)
                    def.schema[kschema] = virtualTypeDef.schema[kschema];
            }
        }

        if (typeof(def.schema.properties) === "undefined" || def.schema.properties === null)
            def.schema.properties = {};

        if (virtualTypeDef.schema && virtualTypeDef.schema.properties) {
            for (var kprop in virtualTypeDef.schema.properties) {
                if (typeof(def.schema.properties[kprop]) === "undefined" || def.schema.properties[kprop] === null)
                    def.schema.properties[kprop] = virtualTypeDef.schema.properties[kprop];
            }
        }

        if (typeof(def.schema.required) === "undefined" || def.schema.required === null)
            def.schema.required = [];

        if (virtualTypeDef.schema && virtualTypeDef.schema.required)
            def.schema.required = def.schema.required.concat(virtualTypeDef.schema.required);

        return def;
    };



    SchemaManager.prototype.buildSchemaCache = function*(entitySchemas, virtualEntitySchemasList) {
        var self = this;

        var def, type;

        //Add the base types
        for(var h = 0; h < entitySchemas.length; h++) {
            def = entitySchemas[h];
            var fullDef = yield* self.completeEntitySchema(def);
            schemaCache[def.schema.id] = fullDef;
        }

        //Add virtual types
        if (virtualEntitySchemasList) {
            for (var i = 0; i < virtualEntitySchemasList.length; i++) {
                var vTypeDefs = virtualEntitySchemasList[i];
                for(var j = 0; j < vTypeDefs.entitySchemas.length; j++) {
                    def = yield* self.completeVirtualEntitySchema(vTypeDefs.entitySchemas[j], vTypeDefs.baseEntitySchema);
                    schemaCache[def.schema.id] = def;
                }
            }
        }

        //References will resolve now.
        for (type in schemaCache) {
            yield* this.resolveReferencesInDef(schemaCache[type]);
        }

        return schemaCache;
    };



    SchemaManager.prototype.resolveReferencesInDef = function*(def, dynamicResolutionContext) {
        var self = this;

        var fn = function*(schema) {
            var subTypeDef;
            if (schema.type === 'object') {
                if (schema.properties) {
                    subTypeDef = {
                        schema: {
                            type: 'object',
                            properties: schema.properties,
                            required: schema.required
                        }
                    };
                    schema.entitySchema = subTypeDef;
                    yield* self.resolveReferencesInDef(subTypeDef, dynamicResolutionContext);
                }
            } else if (schema.$ref) {
                schema.entitySchema = yield* self.getEntitySchema(schema.$ref, dynamicResolutionContext);
                if (!schema.entitySchema) {
                    throw new Error("Unable to resolve " + schema.$ref);
                }
            }
        };

        for (var propertyName in def.schema.properties) {
            var schema = def.schema.properties[propertyName];
            if (schema.type === 'array') {
                yield* fn(schema.items);
            } else {
                yield* fn(schema);
            }
        }
    };


    /*
        Get all cached type definitions
    */
    SchemaManager.prototype.getEntitySchemas = function() {
        return schemaCache;
    };


    /*
        Get a specific type definition based on name, such as "customer" or "apps/forums/1.0.0"
    */
    SchemaManager.prototype.getEntitySchema = function*(name, dynamicResolutionContext) {
        if (schemaCache[name])
            return schemaCache[name];

        if (!dynamicResolutionContext)
            dynamicResolutionContext = {};

        return dynamicResolutionContext[name] || (yield* this.getDynamicEntitySchema(name, dynamicResolutionContext));
    };


    /*
        EntitySchemas that are loaded from the disk or other external sources at runtime.

        Pass this in as options.fn.getDynamicEntitySchema in constructor
        Or override this if using a derived class.
    */
    SchemaManager.prototype.getDynamicEntitySchema = function*(name, dynamicResolutionContext) {
        throw new Error("Cannot find schema for " + name);
    };


    /*
        Pass this in as options.fn.mustConstruct in constructor.
        Or override this if using a derived class
    */
    SchemaManager.prototype.mustConstruct = function(value) {
        return true;
    };



    /*
        Gets a virtual type definition if a discriminator exists
    */
    SchemaManager.prototype.getEffectiveEntitySchema = function*(obj, entitySchema) {
        if (entitySchema.discriminator) {
            return yield* entitySchema.discriminator(obj, this);
        } else {
            return entitySchema;
        }
    };


    /*
        if passed in schema is null, tries to load it via dynamic loader
    */
    SchemaManager.prototype.getPropertySchema = function*(propertyDef, dynamicResolutionContext) {
        if (propertyDef.entitySchema)
            return propertyDef.entitySchema;
        else
            return yield* this.getEntitySchema(propertyDef.$ref, dynamicResolutionContext);
    };


    /*
        Creates a new instance based on the entitySchema
    */
    SchemaManager.prototype.constructEntity = function*(obj, entitySchema, options, dynamicResolutionContext) {
        var effectiveSchema = yield* this.getEffectiveEntitySchema(obj, entitySchema);
        var result = {};
        yield* this.updateEntity(result, obj, effectiveSchema, options, dynamicResolutionContext);
        return effectiveSchema.ctor ? new effectiveSchema.ctor(result) : result;
    };


    /*
        Update properties on target. Target must be an object.
    */
    SchemaManager.prototype.updateEntity = function*(target, obj, entitySchema, options, dynamicResolutionContext) {
        options = options || {};
        dynamicResolutionContext = dynamicResolutionContext || {};

        for (var name in entitySchema.schema.properties) {
            var propertySchema;
            var def = entitySchema.schema.properties[name];
            var value = obj[name];

            if (this.mustConstruct(value)) {
                if (isPrimitiveType(def.type)) {
                    if (value !== undefined && value !== null) {
                        if (def.type === 'array') {
                            if (def.items.entitySchema) {
                                var arr = [];
                                for (var _i = 0; _i < value.length; _i++) {
                                    var item = value[_i];
                                    propertySchema = yield* this.getPropertySchema(def.items, dynamicResolutionContext);
                                    arr.push(yield* this.constructEntity(item, propertySchem, options, dynamicResolutionContext));
                                }
                                value = arr;
                            }
                        }
                    }
                } else {
                    if (def.entitySchema) {
                        if (value) {
                            propertySchema = yield* this.getPropertySchema(def, dynamicResolutionContext);
                            value = yield* this.constructEntity(value, propertySchema, options, dynamicResolutionContext);
                        }
                    }
                }
            }

            if (typeof value != "undefined")
                target[name] = value;
        }

        if (options && options.additionalProperties) {
            options.additionalProperties.forEach(function(f) {
                target[f] = obj[f];
            });
        }

        if (entitySchema.autoGenerated) {
            for (var propertyName in entitySchema.autoGenerated) {
                target[propertyName] = obj[propertyName];
            }
        }

        if (options && options.validate) {
            var errors = yield* this.validate(target, entitySchema);
            if (errors && errors.length) {
                throw new Error("Validation errors: " + errors.toString());
            }
        }
    };


    SchemaManager.prototype.validate = function*(obj, entitySchema) {
        var self = this;
        var promise = new Promise(function(resolve, reject) {
            self.jayschema.validate(obj, entitySchema.schema, function(errors) {
                resolve(errors);
            });
        });
        return yield promise;
	};


	var initted = false;
    SchemaManager.prototype.init = function*(ctors, virtualEntitySchemas) {
        if (!initted) {
            return yield* this.buildSchemaCache(ctors, virtualEntitySchemas);
        } else {
            throw new Error("init() was already called");
        }
    };


    module.exports = SchemaManager;

})();
