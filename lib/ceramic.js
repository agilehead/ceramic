(function() {
    "use strict";

    var Validator = require('./validator');

    /*
        TODO: Well, this is kinda simplistic.
    */
    var isPrimitiveType = function(type) {
        return ['string', 'number', 'integer', 'boolean', 'array'].indexOf(type) > -1;
    };

    var schemaCache = {};

    var SchemaManager = function(options) {
        this.validator = new Validator(this);

        if (options) {
            if (options.fn) {
                /*
                    isModel and getDynamicEntitySchema can also be substituted by deriving from SchemaManager
                */
                if (options.fn.isModel)
                    this.isModel = options.fn.isModel;

                if (options.fn.getDynamicEntitySchema)
                    this.getDynamicEntitySchema = options.fn.getDynamicEntitySchema;
            }
        }
    };


    SchemaManager.prototype.completeEntitySchema = function*(def) {
        if (!def.schema) {
            def.schema = {};
        }
        if (!def.schema.properties) {
            def.schema.properties = {};
        }
        if (!def.schema.required) {
            def.schema.required = [];
        }
        if (def.autoGenerated) {
            for (var k in def.autoGenerated) {
                def.schema.properties[k] = {
                    type: 'integer'
                };
                def.schema.required.push(k);
            }
        }

        return def;
    };



    SchemaManager.prototype.completeVirtualEntitySchema = function*(virtualTypeDef, baseEntitySchema) {
        var def = JSON.parse(JSON.stringify(baseEntitySchema));

        def.baseEntitySchema = baseEntitySchema;
        def.name = virtualTypeDef.name;

        for (var kvirt in virtualTypeDef) {
            if (typeof(def[kvirt]) === "undefined" || def[kvirt] === null)
                def[kvirt] = virtualTypeDef[kvirt];
        }

        if (typeof(def.schema) === "undefined" || def.schema === null)
            def.schema = {};

        if (virtualTypeDef.schema) {
            for (var kschema in virtualTypeDef.schema) {
                if (typeof(def.schema[kschema]) === "undefined" || def.schema[kschema] === null)
                    def.schema[kschema] = virtualTypeDef.schema[kschema];
            }
        }

        if (typeof(def.schema.properties) === "undefined" || def.schema.properties === null)
            def.schema.properties = {};

        if (virtualTypeDef.schema && virtualTypeDef.schema.properties) {
            for (var kprop in virtualTypeDef.schema.properties) {
                if (typeof(def.schema.properties[kprop]) === "undefined" || def.schema.properties[kprop] === null)
                    def.schema.properties[kprop] = virtualTypeDef.schema.properties[kprop];
            }
        }

        if (typeof(def.schema.required) === "undefined" || def.schema.required === null)
            def.schema.required = [];

        if (virtualTypeDef.schema && virtualTypeDef.schema.required)
            def.schema.required = def.schema.required.concat(virtualTypeDef.schema.required);

        return def;
    };



    SchemaManager.prototype.buildSchemaCache = function*(entitySchemas, virtualEntitySchemasList) {
        var self = this;

        var def, type;

        //Add the base types
        for(var h = 0; h < entitySchemas.length; h++) {
            def = entitySchemas[h];
            var fullDef = yield* self.completeEntitySchema(def);
            schemaCache[def.name] = fullDef;
        }

        //Add virtual types
        if (virtualEntitySchemasList) {
            for (var i = 0; i < virtualEntitySchemasList.length; i++) {
                var vTypeDefs = virtualEntitySchemasList[i];
                for(var j = 0; j < vTypeDefs.entitySchemas.length; j++) {
                    def = yield* self.completeVirtualEntitySchema(vTypeDefs.entitySchemas[j], vTypeDefs.baseEntitySchema);
                    schemaCache[def.name] = def;
                }
            }
        }

        //References will resolve now.
        for (type in schemaCache) {
            yield* this.resolveReferencesInDef(schemaCache[type]);
        }

        return schemaCache;
    };



    SchemaManager.prototype.resolveReferencesInDef = function*(def, dynamicResolutionContext) {
        var self = this;

        var fn = function*(prop, val) {
            var subTypeDef;
            if (val.type === 'object') {
                if (val.properties) {
                    subTypeDef = {
                        name: "<anonymous>",
                        schema: {
                            type: val.type,
                            properties: val.properties,
                            required: val.required
                        }
                    };
                    prop.entitySchema = subTypeDef;
                    yield* self.resolveReferencesInDef(subTypeDef, dynamicResolutionContext);
                }
            } else if (val.$ref) {
                prop.entitySchema = yield* self.getEntitySchema(val.$ref, dynamicResolutionContext);
                if (!prop.entitySchema) {
                    throw new Error("Unable to resolve " + val.$ref);
                }
            }
        };

        for (var property in def.schema.properties) {
            var value = def.schema.properties[property];
            if (value.type === 'array') {
                yield* fn(def.schema.properties[property].items, value.items);
            } else {
                yield* fn(def.schema.properties[property], value);
            }
        }
    };


    /*
        Get all cached type definitions
    */
    SchemaManager.prototype.getEntitySchemas = function() {
        return schemaCache;
    };


    /*
        Get a specific type definition based on name, such as "customer" or "apps/forums/1.0.0"
    */
    SchemaManager.prototype.getEntitySchema = function*(name, dynamicResolutionContext) {
        if (schemaCache[name])
            return schemaCache[name];

        if (!dynamicResolutionContext)
            dynamicResolutionContext = {};

        return dynamicResolutionContext[name] || (yield* this.getDynamicEntitySchema(name, dynamicResolutionContext));
    };


    /*
        EntitySchemas that are loaded from the disk or other external sources at runtime.

        Pass this in as options.fn.getDynamicEntitySchema in constructor
        Or override this if using a derived class.
    */
    SchemaManager.prototype.getDynamicEntitySchema = function*(name, dynamicResolutionContext) {
        throw new Error("Cannot find schema for " + name);
    };


    /*
        Pass this in as options.fn.isModel in constructor.
        Or override this if using a derived class
    */
    SchemaManager.prototype.isModel = function(value) {
        return false;
    };



    /*
        Gets a virtual type definition if a discriminator exists
    */
    SchemaManager.prototype.getEffectiveEntitySchema = function*(obj, entitySchema) {
        if (entitySchema.discriminator) {
            return yield* entitySchema.discriminator(obj, this);
        } else {
            return entitySchema;
        }
    };


    /*
        Creates a new instance based on the entitySchema
    */
    SchemaManager.prototype.constructEntity = function*(obj, entitySchema, options) {
        var effectiveSchema = yield* this.getEffectiveEntitySchema(obj, entitySchema);
        var result = {};
        yield* this.updateEntity(result, obj, effectiveSchema, options);
        return effectiveSchema.ctor ? new effectiveSchema.ctor(result) : result;
    };


    /*
        Update fields on target. Target must be an object.
    */
    SchemaManager.prototype.updateEntity = function*(target, obj, entitySchema, options) {
        for (var name in entitySchema.schema.properties) {
            var arr;
            var def = entitySchema.schema.properties[name];
            var value = obj[name];

            if (!this.isModel(value)) {
                if (isPrimitiveType(def.type)) {
                    if (value !== undefined && value !== null) {
                        if (def.type === 'array') {
                            if (def.items.entitySchema) {
                                arr = [];
                                for (var _i = 0; _i < value.length; _i++) {
                                    var item = value[_i];
                                    arr.push(yield* this.constructEntity(item, def.items.entitySchema, options));
                                }
                                value = arr;
                            }
                        }
                    }
                } else {
                    if (def.entitySchema) {
                        if (value) {
                            value = yield* this.constructEntity(value, def.entitySchema, options);
                        }
                    }
                }
            }

            target[name] = value;
        }

        if (options && options.systemFields) {
            options.systemFields.forEach(function(f) {
                target[f] = obj[f];
            });
        }

        if (entitySchema.autoGenerated) {
            for (var fieldName in entitySchema.autoGenerated) {
                target[fieldName] = obj[fieldName];
            }
        }

        if (options && options.validate) {
            var errors = yield* this.validate(target, entitySchema);
            if (errors.length) {
                throw new Error("Validation errors: " + errors.toString());
            }
        }
    };


    SchemaManager.prototype.validate = function*(obj, entitySchema) {
        return yield* this.validator.validate(obj, entitySchema);
	};


    SchemaManager.prototype.validateField = function*(obj, value, fieldName, fieldDef) {
        return yield* this.validator.validateField(obj, value, fieldName, fieldDef);
	};


	var initted = false;
    SchemaManager.prototype.init = function*(ctors, virtualEntitySchemas) {
        if (!initted) {
            return yield* this.buildSchemaCache(ctors, virtualEntitySchemas);
        } else {
            throw new Error("init() was already called");
        }
    };


    module.exports = SchemaManager;

})();
