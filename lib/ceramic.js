(function() {
  "use strict";

  var co = require("co");
  var generatorify = require('nodefunc-generatorify');
  var JaySchema = require('jayschema');

  /*
  TODO: Well, this is kinda simplistic.
  */
  var isPrimitiveType = function(type) {
    return ['string', 'number', 'integer', 'boolean', 'array'].indexOf(type) > -1;
  };

  var schemaCache = {};


  var schemaLoader = function(name, cb) {
    var self = this;
    co(function*() {
      try {
        var entitySchema = yield* self.getEntitySchema(name);
        cb(null, entitySchema.schema);
      } catch (err) {
        cb(err);
      }
    });
  };


  var SchemaManager = function(options) {
    if (options) {
      if (options.fn) {
        //mustConstruct can also be substituted by deriving from SchemaManager
        if (options.fn.mustConstruct)
        this.mustConstruct = options.fn.mustConstruct;

        //getDynamicEntitySchema can also be substituted by deriving from SchemaManager
        if (options.fn.getDynamicEntitySchema)
        this.getDynamicEntitySchema = options.fn.getDynamicEntitySchema;
      }
    }

    var jayschema = new JaySchema(schemaLoader.bind(this));

    this.jayschemaValidate = function(obj, schema) {
      var promise = new Promise(function(resolve, reject) {
        jayschema.validate(obj, schema, function(results) {
          resolve(results);
        });
      });
      return promise;
    };
  };


  SchemaManager.prototype.completeEntitySchema = function*(def) {
    if (!def.schema || !def.schema.id)
    throw new Error("missing schema.id in " + JSON.stringify(def));

    if (!def.schema.properties) {
      def.schema.properties = {};
    }
    if (!def.schema.required) {
      def.schema.required = [];
    }
    if (def.autoGenerated) {
      for (var k in def.autoGenerated) {
        def.schema.properties[k] = {
          type: 'integer'
        };
        def.schema.required.push(k);
      }
    }

    return def;
  };



  SchemaManager.prototype.completeVirtualEntitySchema = function*(virtualTypeDef, baseEntitySchema) {
    var def = JSON.parse(JSON.stringify(baseEntitySchema));

    def.schema.id = virtualTypeDef.schema.id;
    def.baseEntitySchema = baseEntitySchema;

    for (var kvirt in virtualTypeDef) {
      if (typeof(def[kvirt]) === "undefined" || def[kvirt] === null)
      def[kvirt] = virtualTypeDef[kvirt];
    }

    if (typeof(def.schema) === "undefined" || def.schema === null)
    def.schema = {};

    if (virtualTypeDef.schema) {
      for (var kschema in virtualTypeDef.schema) {
        if (typeof(def.schema[kschema]) === "undefined" || def.schema[kschema] === null)
        def.schema[kschema] = virtualTypeDef.schema[kschema];
      }
    }

    if (typeof(def.schema.properties) === "undefined" || def.schema.properties === null)
    def.schema.properties = {};

    if (virtualTypeDef.schema && virtualTypeDef.schema.properties) {
      for (var kprop in virtualTypeDef.schema.properties) {
        if (typeof(def.schema.properties[kprop]) === "undefined" || def.schema.properties[kprop] === null)
        def.schema.properties[kprop] = virtualTypeDef.schema.properties[kprop];
      }
    }

    if (typeof(def.schema.required) === "undefined" || def.schema.required === null)
    def.schema.required = [];

    if (virtualTypeDef.schema && virtualTypeDef.schema.required)
    def.schema.required = def.schema.required.concat(virtualTypeDef.schema.required);

    return def;
  };



  SchemaManager.prototype.buildSchemaCache = function*(entitySchemas, virtualEntitySchemasList) {
    var self = this;

    var def, type;

    //Add the base types
    for(var h = 0; h < entitySchemas.length; h++) {
      def = entitySchemas[h];
      var fullDef = yield* self.completeEntitySchema(def);
      schemaCache[def.schema.id] = fullDef;
    }

    //Add virtual types
    if (virtualEntitySchemasList) {
      for (var i = 0; i < virtualEntitySchemasList.length; i++) {
        var vTypeDefs = virtualEntitySchemasList[i];
        for(var j = 0; j < vTypeDefs.entitySchemas.length; j++) {
          def = yield* self.completeVirtualEntitySchema(vTypeDefs.entitySchemas[j], vTypeDefs.baseEntitySchema);
          schemaCache[def.schema.id] = def;
        }
      }
    }

    //References will resolve now.
    for (type in schemaCache) {
      yield* this.resolveReferencesInDef(schemaCache[type]);
    }

    return schemaCache;
  };



  SchemaManager.prototype.resolveReferencesInDef = function*(def, dynamicResolutionContext) {
    var self = this;

    var fn = function*(schema) {
      var subTypeDef;
      if (schema.type === 'object') {
        if (schema.properties) {
          subTypeDef = {
            schema: {
              type: 'object',
              properties: schema.properties,
              required: schema.required
            }
          };
          schema.entitySchema = subTypeDef;
          yield* self.resolveReferencesInDef(subTypeDef, dynamicResolutionContext);
        }
      } else if (schema.$ref) {
        schema.entitySchema = yield* self.getEntitySchema(schema.$ref, dynamicResolutionContext);
        if (!schema.entitySchema) {
          throw new Error("Unable to resolve " + schema.$ref);
        }
      }
    };

    for (var propertyName in def.schema.properties) {
      var schema = def.schema.properties[propertyName];
      if (schema.type === 'array') {
        yield* fn(schema.items);
      } else {
        yield* fn(schema);
      }
    }
  };


  /*
  Get all cached type definitions
  */
  SchemaManager.prototype.getEntitySchemas = function() {
    return schemaCache;
  };


  /*
  Get a specific type definition based on name, such as "customer" or "apps/forums/1.0.0"
  */
  SchemaManager.prototype.getEntitySchema = function*(name, dynamicResolutionContext) {
    if (schemaCache[name])
    return schemaCache[name];

    if (!dynamicResolutionContext)
    dynamicResolutionContext = {};

    return dynamicResolutionContext[name] || (yield* this.getDynamicEntitySchema(name, dynamicResolutionContext));
  };


  /*
  EntitySchemas that are loaded from the disk or other external sources at runtime.

  Pass this in as options.fn.getDynamicEntitySchema in constructor
  Or override this if using a derived class.
  */
  SchemaManager.prototype.getDynamicEntitySchema = function*(name, dynamicResolutionContext) {
    throw new Error("Cannot find schema for " + name);
  };


  /*
  Pass this in as options.fn.mustConstruct in constructor.
  Or override this if using a derived class
  */
  SchemaManager.prototype.mustConstruct = function(value) {
    return true;
  };



  /*
  Gets a virtual type definition if a discriminator exists
  */
  SchemaManager.prototype.getEffectiveEntitySchema = function*(obj, entitySchema) {
    if (entitySchema.discriminator) {
      return yield* entitySchema.discriminator(obj, this);
    } else {
      return entitySchema;
    }
  };


  /*
  if passed in schema is null, tries to load it via dynamic loader
  */
  SchemaManager.prototype.getPropertySchema = function*(propertyDef, dynamicResolutionContext) {
    if (propertyDef.entitySchema)
    return propertyDef.entitySchema;
    else
    return yield* this.getEntitySchema(propertyDef.$ref, dynamicResolutionContext);
  };


  /*
  Creates a new instance based on the entitySchema
  */
  SchemaManager.prototype.constructEntity = function*(obj, entitySchema, options, dynamicResolutionContext) {
    var result = yield* constructEntity.call(this, obj, entitySchema, options, dynamicResolutionContext);

    if (options && options.validate) {
      var errors = yield* this.validate(result.entity, result.schema);
      if (errors && errors.length) {
        throw new Error("Validation errors: " + errors.toString());
      }
    }

    return result.entity;
  };


  var constructEntity = function*(obj, entitySchema, options, dynamicResolutionContext) {
    var result = {};
    var effectiveSchema = yield* this.getEffectiveEntitySchema(obj, entitySchema);
    yield* this.updateEntity(result, obj, effectiveSchema, options, dynamicResolutionContext);
    return {
      entity: effectiveSchema.ctor ? new effectiveSchema.ctor(result) : result,
      schema: effectiveSchema
    };
  };


  /*
  Update properties on target. Target must be an object.
  */
  SchemaManager.prototype.updateEntity = function*(target, obj, entitySchema, options, dynamicResolutionContext) {
    options = options || {};
    dynamicResolutionContext = dynamicResolutionContext || {};

    for (var name in entitySchema.schema.properties) {
      var propertySchema;
      var def = entitySchema.schema.properties[name];
      var value = obj[name];

      var constructionResult;
      if (this.mustConstruct(value)) {
        if (isPrimitiveType(def.type)) {
          if (value !== undefined && value !== null) {
            if (def.type === 'array') {
              if (def.items.entitySchema) {
                var arr = [];
                for (var _i = 0; _i < value.length; _i++) {
                  var item = value[_i];
                  propertySchema = yield* this.getPropertySchema(def.items, dynamicResolutionContext);
                  constructionResult = yield* constructEntity.call(this, item, propertySchem, options, dynamicResolutionContext);
                  arr.push(constructionResult.entity);
                }
                value = arr;
              }
            }
          }
        } else {
          if (def.entitySchema) {
            if (value) {
              propertySchema = yield* this.getPropertySchema(def, dynamicResolutionContext);
              constructionResult = yield* constructEntity.call(this, value, propertySchema, options, dynamicResolutionContext);
              value = constructionResult.entity;
            }
          }
        }
      }

      if (typeof value != "undefined")
      target[name] = value;
    }

    if (options && options.additionalProperties) {
      options.additionalProperties.forEach(function(f) {
        var propVal = obj[f];
        if (typeof propVal !== "undefined") {
          target[f] = propVal;
        }
      });
    }

    if (entitySchema.autoGenerated) {
      for (var propertyName in entitySchema.autoGenerated) {
        target[propertyName] = obj[propertyName];
      }
    }
  };


  SchemaManager.prototype.validate = function*(obj, entitySchema) {
    return yield this.jayschemaValidate(obj, entitySchema.schema);
  };


  var initted = false;
  SchemaManager.prototype.init = function*(ctors, virtualEntitySchemas) {
    if (!initted) {
      return yield* this.buildSchemaCache(ctors, virtualEntitySchemas);
    } else {
      throw new Error("init() was already called");
    }
  };


  module.exports = SchemaManager;

})();
